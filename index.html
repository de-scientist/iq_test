<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>60-question Calibrated IQ Assessment — Self-marking</title>
<link rel="stylesheet" href="./src/style.css">
</head>
<body>
  <div class="app card" id="app">
    <header>
      <div style="width:52px;height:52px;border-radius:12px;background:linear-gradient(180deg,#04293a,#06304a);display:flex;align-items:center;justify-content:center;font-weight:800;color:var(--accent)">IQ</div>
      <div>
        <h1>60-question Calibrated IQ Assessment — Self-marking</h1>
        <div class="small">Now with normed-scale IQ calibration, printable certificate (PDF via Print), per-user CSV export, randomized timed order, and expanded explanations.</div>
      </div>
    </header>

    <div class="meta" style="margin-top:12px">
      <div style="display:flex;gap:8px;align-items:center">
        <div class="tag">60 Questions</div>
        <div class="tag">4 Sections</div>
        <div class="tag">Calibrated IQ</div>
      </div>
      <div class="controls">
        <div class="small">Status: <strong id="status">Not started</strong></div>
        <button id="startBtn">Start assessment</button>
      </div>
    </div>

    <div id="setup" class="start-area">
      <div class="card" style="padding:12px">
        <h3>How this works</h3>
        <ol class="small" style="margin:8px 0 0 16px">
          <li>Four sections (15 q each): Logic, Numerical, Verbal, Spatial.</li>
          <li>Set per-section time; questions are shuffled by difficulty within each section.</li>
          <li>On finish you get a calibrated IQ estimate (normed using binomial model), detailed breakdown, CSV export, and printable certificate.</li>
        </ol>
        <p class="small" style="margin-top:8px">This remains a practice tool, not a clinical instrument. Calibration approximates population norms for learning purposes.</p>
      </div>

      <div class="card" style="padding:12px">
        <div class="small">Choose timings (minutes)</div>
        <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
          <label class="small">Per-section:</label>
          <select id="timeSelect">
            <option value="10">10</option>
            <option value="12">12</option>
            <option value="15" selected>15</option>
            <option value="20">20</option>
          </select>
          <div class="small" style="margin-left:auto">Estimated total: <span id="est">60</span> min</div>
        </div>

        <div style="margin-top:12px;display:flex;gap:8px">
          <button id="startBtn2">Begin now</button>
          <button class="ghost" id="demoBtn">Demo (short)</button>
        </div>
      </div>
    </div>

    <div id="quiz" class="quiz-area" style="display:none">
      <div class="section-title">
        <div>
          <div class="small">Section <span id="secIndex">1</span> of 4</div>
          <h2 id="secName">Logic — 15 q</h2>
          <div class="small" id="secDesc">Timed. Questions are mixed by difficulty.</div>
        </div>
        <div style="text-align:right">
          <div class="timer" id="timer">15:00</div>
          <div style="margin-top:8px" class="progress" id="globalProg" style="width:240px"><i id="progBar"></i></div>
        </div>
      </div>

      <div id="questionArea"></div>

      <div class="nav" style="margin-top:10px">
        <button id="prevBtn">Previous</button>
        <button id="nextBtn">Next</button>
        <button id="submitSectionBtn" style="margin-left:auto;background:#ef4444;color:white">Submit section</button>
      </div>
    </div>

    <div id="results" style="display:none" class="results">
      <h3>Results</h3>
      <div id="summary"></div>
      <div id="breakdown" style="margin-top:8px"></div>
      <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
        <button id="downloadCSV">Download CSV (results)</button>
        <button id="printCert">Generate Printable Certificate</button>
        <button id="retry" class="ghost">Retry (reshuffle)</button>
      </div>

      <div style="margin-top:12px" class="review">
        <h4>Review answers (expand for explanations)</h4>
        <div id="reviewList" style="max-height:360px;overflow:auto;padding-right:6px"></div>
      </div>
    </div>

    <div class="cert" id="cert">
      <div style="text-align:center;margin-bottom:12px"><h2>Certificate of Completion</h2><div class="small">60-question Calibrated IQ Assessment</div></div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px">
        <div><strong id="certName">Name: —</strong><div class="small" id="certDate"></div></div>
        <div style="text-align:right"><div style="font-size:28px;font-weight:800" id="certIQ">IQ —</div><div class="small" id="certDetail">Score —</div></div>
      </div>
      <div style="margin-top:18px" class="small">This certificate reflects completion of a timed, self-administered practice assessment and presents a calibrated estimate based on raw performance against a binomial normative model. For official evaluation consult a licensed psychologist.</div>
    </div>

    <footer style="margin-top:12px" class="small">Built for practice & learning. — De-Scientist</footer>
  </div>

  <script>
    /* Enhanced features added:
       - difficulty field and explanation per question
       - randomization within sections (stratified by difficulty)
       - calibrated IQ using binomial mean/sd
       - CSV export
       - printable certificate via window.print()
    */


    // references
   

    function updateEstimate(){ const mins=parseInt(timeSelect.value); est.textContent = mins*state.sections.length; }
    timeSelect.addEventListener('change', updateEstimate); updateEstimate();

    // Stratified shuffle: keep difficulty mix by shuffling then grouping easy/medium/hard
    function stratifiedShuffleQuestions(){
      state.orderMap = {};
      for(const sec of state.sections){
        const easy = sec.questions.filter(q=>q.difficulty==='E');
        const med = sec.questions.filter(q=>q.difficulty==='M');
        const hard = sec.questions.filter(q=>q.difficulty==='H');
        shuffle(easy); shuffle(med); shuffle(hard);
        // interleave: M,H,E to create mix, or simple concat M,H,E then shuffle again lightly
        const mixed = [].concat(med.slice(0,5), hard.slice(0,5), easy.slice(0,5));
        // if fewer than 15 in each, fill from remaining
        if(mixed.length<sec.questions.length){
          const rest = sec.questions.filter(q=>!mixed.includes(q));
          shuffle(rest); mixed.push(...rest);
        }
        // final mild shuffle to avoid patterns but preserve difficulty spread
        for(let i=0;i<3;i++){ shuffle(mixed); }
        state.orderMap[sec.name] = mixed.map(q=>q.id);
      }
    }

    function startDemo(){ state.perSectionMinutes=1; startTest(); }
    function startTest(){ if(state.started) return; state.perSectionMinutes = parseInt(timeSelect.value); state.started=true; state.currentSectionIndex=0; state.answers={}; setup.style.display='none'; quiz.style.display='block'; status.textContent='In progress'; stratifiedShuffleQuestions(); gotoSection(0);}    

    function gotoSection(idx){ clearInterval(state.timerInterval); state.currentSectionIndex=idx; const sec = state.sections[idx]; secIndex.textContent = (idx+1); secName.textContent = sec.name + ' (' + sec.questions.length + ' q)'; secDesc.textContent = `${sec.questions.length} questions — mixed difficulty.`; state.remaining = state.perSectionMinutes*60; updateTimerDisplay(); state.timerInterval = setInterval(()=>{ state.remaining--; updateTimerDisplay(); if(state.remaining<=0){ clearInterval(state.timerInterval); autoSubmitSection(); } },1000); renderQuestion(0); updateProgressBar(); }

    function updateTimerDisplay(){ const m = Math.floor(state.remaining/60).toString().padStart(2,'0'); const s = (state.remaining%60).toString().padStart(2,'0'); timerEl.textContent = `${m}:${s}`; }

    function renderQuestion(qIndex){
      const sec = state.sections[state.currentSectionIndex];
      const order = state.orderMap[sec.name];
      const qid = order[qIndex];
      const q = QUESTIONS.find(x=>x.id===qid);
      questionArea.innerHTML='';
      const info = document.createElement('div'); info.className='small'; info.innerHTML = `Q ${qIndex+1} of ${sec.questions.length} — ID ${q.id} — Difficulty: ${q.difficulty}`;
      questionArea.appendChild(info);
      const qbox = document.createElement('div'); qbox.className='question'; qbox.innerHTML = `<div style="font-weight:700">${q.q}</div>`;
      const opts = document.createElement('div'); opts.className='options';
      q.opts.forEach((o,i)=>{ const div=document.createElement('div'); div.className='opt'; div.tabIndex=0; div.innerHTML = `<div>${String.fromCharCode(65+i)}. ${o}</div>`; if(state.answers[q.id]===i) div.classList.add('selected'); div.addEventListener('click', ()=>{ selectOption(q.id,i); renderQuestion(qIndex); updateProgressBar(); }); opts.appendChild(div); });
      qbox.appendChild(opts);
      const nav = document.createElement('div'); nav.style.marginTop='.8rem';
      for(let i=0;i<sec.questions.length;i++){ const b=document.createElement('button'); b.textContent=(i+1); b.className='small'; b.style.borderRadius='8px'; if(state.answers[order[i]]!==undefined) b.style.borderColor='#7dd3fc'; b.addEventListener('click', ()=>{ renderQuestion(i); }); nav.appendChild(b); }
      qbox.appendChild(nav); questionArea.appendChild(qbox);
      prevBtn.onclick = ()=>{ const ni=Math.max(0,qIndex-1); renderQuestion(ni); }
      nextBtn.onclick = ()=>{ const ni=Math.min(sec.questions.length-1,qIndex+1); renderQuestion(ni); }
      submitSectionBtn.onclick = ()=>{ submitSection(); }
    }

    function selectOption(qid, idx){ state.answers[qid]=idx; }
    function updateProgressBar(){ const total=QUESTIONS.length; let done=0; for(const id in state.answers) done++; const pct=Math.round((done/total)*100); progBar.style.width=pct+'%'; }
    function autoSubmitSection(){ alert('Time is up for this section. Submitting and moving to next.'); submitSection(); }
    function submitSection(){ clearInterval(state.timerInterval); const next = state.currentSectionIndex+1; if(next<state.sections.length){ gotoSection(next); } else { finishTest(); } }

    function finishTest(){ state.started=false; quiz.style.display='none'; resultsEl.style.display='block'; status.textContent='Completed'; computeResults(); }

    function computeResults(){ let correctCount=0; const perSectionScores={}; for(const sec of state.sections){ let sCorrect=0; for(const q of sec.questions){ const chosen = state.answers[q.id]; if(chosen===q.a){ correctCount++; sCorrect++; } } perSectionScores[sec.name]={correct:sCorrect,total:sec.questions.length}; }
      // Calibration using binomial model (p=0.5 assumed average chance)
      const raw = correctCount; const N = QUESTIONS.length; const p = 0.5; const meanRaw = N*p; const sdRaw = Math.sqrt(N*p*(1-p)); const z = (raw - meanRaw) / sdRaw; const iq = Math.round(100 + 15*z);

      summaryEl.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div><strong>Raw score:</strong> ${raw} / ${N}</div><div><strong>Calibrated IQ estimate:</strong> ${iq}</div></div><div class="small" style="margin-top:6px">Calibration note: estimate derived from raw score using a binomial mean/sd model (p=0.5). This produces a normative-like IQ mapping for practice only.</div>`;

      // breakdown
      let html=`<table><thead><tr><th>Section</th><th>Correct</th><th>Total</th><th>Percent</th></tr></thead><tbody>`;
      for(const k of Object.keys(perSectionScores)){ const o=perSectionScores[k]; const pct=Math.round((o.correct/o.total)*100); html+=`<tr><td>${k}</td><td>${o.correct}</td><td>${o.total}</td><td>${pct}%</td></tr>`; }
      html+=`</tbody></table>`; breakdownEl.innerHTML=html;

      // review list with explanations
      let rhtml=''; for(const sec of state.sections){ const order = state.orderMap[sec.name]; for(let i=0;i<order.length;i++){ const qid=order[i]; const q=QUESTIONS.find(x=>x.id===qid); const chosen=state.answers[q.id]; const isCorrect = chosen===q.a; rhtml+=`<div style="padding:10px;border-bottom:1px solid rgba(0,0,0,0.06)"><div style="font-weight:700">(${q.section}) Q${q.id}</div><div class="small" style="margin-top:4px">${q.q}</div><div style="margin-top:6px">Your: <strong style="color:${isCorrect? 'var(--success)':'var(--danger)'}">${chosen===undefined? '—' : String.fromCharCode(65+chosen)+'. '+q.opts[chosen]}</strong> — Correct: <strong>${String.fromCharCode(65+q.a)}. ${q.opts[q.a]}</strong></div><div class="small" style="margin-top:6px">Explanation: ${q.expl || '—'}</div></div>`; } }
      reviewList.innerHTML = rhtml;

      // prepare certificate values
      const name = 'Participant'; const date = new Date().toLocaleString(); certName.textContent = `Name: ${name}`; certDate.textContent = `Completed: ${date}`; certIQ.textContent = `${iq}`; certDetail.textContent = `Raw score: ${raw} / ${N}`;

      // wire CSV and print
      downloadCSV.onclick = ()=>{ const csv = buildCSV(raw,iq); const blob = new Blob([csv],{type:'text/csv'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='iq_results.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); };
      printCert.onclick = ()=>{ // fill certificate with participant data then print
        certName.textContent = `Name: ${prompt('Enter name for certificate (leave blank for Participant)') || 'Participant'}`; certDate.textContent = `Completed: ${new Date().toLocaleString()}`; window.print(); };
      retry.onclick = ()=>{ // reshuffle and restart
        resultsEl.style.display='none'; setup.style.display='block'; status.textContent='Not started'; stratifiedShuffleQuestions(); }
    }

    function buildCSV(raw,iq){ const rows=[]; rows.push(['QuestionID','Section','Question','ChosenOptionIndex','ChosenOptionLabel','CorrectIndex','CorrectLabel','Difficulty','Explanation'].join(',')); for(const sec of state.sections){ const order = state.orderMap[sec.name]; for(let i=0;i<order.length;i++){ const qid=order[i]; const q=QUESTIONS.find(x=>x.id===qid); const chosen = state.answers[q.id]; const chosenLabel = chosen===undefined? '': `${String.fromCharCode(65+chosen)}. ${q.opts[chosen]}`; const correctLabel = `${String.fromCharCode(65+q.a)}. ${q.opts[q.a]}`; // escape commas and quotes
          const esc = s=>('"'+String(s).replace(/"/g,'""')+'"'); rows.push([q.id,q.section,esc(q.q),(chosen===undefined?'':chosen),esc(chosenLabel),q.a,esc(correctLabel),q.difficulty,esc(q.expl)].join(',')); } }
      rows.push(['RawScore',raw,'CalibratedIQ',iq].join(',')); return rows.join('
'); }

    // wire start
    document.getElementById('startBtn').addEventListener('click', startTest);
    document.getElementById('startBtn2').addEventListener('click', startTest);
    demoBtn.addEventListener('click', startDemo);

    // initial
    function initialPreview(){ secIndex.textContent='—'; secName.textContent='Preview'; secDesc.textContent='Pick timings and start.'; }
    initialPreview();

  </script>
</body>
</html>
